
From FinMatrix Require MatrixR MatrixC.

(* 为了能简短的访问到复数域上的矩阵和向量，使用新的模块名称 *)
Module Import RM := MatrixR.
Module Import CM := MatrixC.

(* 四元数 *)
(* Require Import Quaternion. *)

Open Scope R_scope.
Open Scope vec_scope.
Open Scope mat_scope.

(** ch8 三维旋转 *)

(* 本章将解决描述三维中对象的方向的难题，还讨论与旋转和角位移有关的概念。
   有若干方法来表示三维中的方向的角位移。三个重要方法：矩阵、欧拉角和四元数，
   以及两个鲜为人知的形式——轴角和指数映射。对每种方法，精确定义表示方法的工作原理，
   并讨论该方法的特性和优缺点。
   不同情况需要不同的技术，各种技术有其优缺点。开发人员不仅要知道每种方法的工作原理，
   还需要知道哪种技术最适合特定情况以及如何在表示方式之间进行转换。*)

(** * 8.1 “定向、朝向（Orientation）”是什么？ *)

(* 术语 Orientation 与这些相似的术语有关：
   方向 direction
   角位移 angular displacement
   旋转 rotation

   方向和朝向的根本区别：可用两个数字（球面坐标的角度）来设置三维中的方向；而朝向至少
   需要三个数字（比如欧拉角）。
   可以这样理解：在没有参考系时无法描述一个物体的位置。同样的，定向也不能用一些绝对项
   来描述。可以从一些已知的参考方向（长称为 identity 或 home 朝向）的旋转给出朝向。
   旋转量称为角位移（angular displacement）。
   换言之，描述朝向在数学上等同于描述角位移。

   定向描述了事务的一种状态。
   定向和角位移之间的区别，类似于点和矢量之间的区别。这两个术语在数学上等价，但概念上不同。
   此时，定向主要用于描述单个状态，而角位移主要用于描述两个状态之间的差异。

   这些约定是一个偏好问题，但可能对准确了解其含义和用法有所帮助。

   可能还会听到用于表示对象的定向的一个词“姿态（attitude）”，特别当该对象是飞机时。*)

(** * 8.2 矩阵形式 Matrix form *)

(* 描述3D中坐标空间的定向的一种方法：指出该坐标空间(+x,+y,+z轴）的基矢量的方向。
   根据定义，无论坐标空间的定向是什么，它们都是[1,0,0], [0,1,0], [0,0,1]。
   我们必须使用某些其他坐标空间来描述基向量。如此依赖，就可以建立两个坐标空间
   的相对朝向。

   当这些基向量用于形成3x3矩阵的行（或列）时，就是用矩阵形式（Matrix Form）表示了定向。
   另一种说法是，我们可以给出旋转矩阵表达两个坐标空间的相对朝向，旋转矩阵能够用于将向量
   从一个坐标空间变换到另一个坐标空间。*)

(** ** 8.2.1 矩阵的选择 *)
Section sec_8_2_1.
  (* 图8.3中的旋转矩阵，机体坐标空间的对象轴在直立空间中的表示在矩阵的行（也可以是列）中，
   同时，它可以将行矢量乘以该矩阵（也可以是该矩阵的转置乘以列矢量），将这些矢量从对象空间
   坐标变换为直立空间坐标。*)

  (* 一个合法性问题：为什么矩阵包含直立空间坐标下表示的体轴？为什么不用对象空间坐标来表示
     直立轴？换言之，为什么选择用一个旋转矩阵来将矢量从对象空间变换到直立空间？而不是从
     直立空间变换到对象空间呢？
     从数学上看，该问题有点可笑。因为旋转矩阵是正交的，其逆矩阵和它的转置相同。所以，
     该决定是一个很表面的（cosmetic）选择。
     但实际上，在我们看来，这很重要。问题在于你是否可以编写直观易读的代码，是否需要大量
     的约定知识。

     编程人员经常要用以下两种策略来编写程序：
     1. 一些矢量从对象空间旋转到直立空间，将其转换为矩阵乘法的代码
     2. 一些矢量从直立空间旋转到对象空间，将其转换为矩阵的逆(或转置)的乘法的代码。
     另外，如果是行矢量则左乘，列矢量则右乘，矩阵可能还要转置。
     这种使用矩阵的约定，往往是一个使用时的障碍，也是错误的来源。

     我们可以设计更好的接口函数来符合程序员高层次意图，封装与行矢量、列矢量、左乘、右乘、
     逆矩阵、转置等有关的容易混淆的线性代数的细节。
     回到一开始的问题：应该使用哪一个矩阵？答案是：它应该无关紧要。也许我们用函数
     objectToUpright() 来替换原来的 mmul()，类似的，用uprightToObject() 替换
     mmulByTranspose()。具有描述性命名坐标空间的代码版本显然更易于编写和阅读。*)
End sec_8_2_1.

(** ** 8..2 方向余弦矩阵 *)
Section sec_8_2_2.
  Import RM.
  (* 方向余弦（Direction Cosine）矩阵与旋转矩阵相同，该术语只是指一种解释（或构造）矩阵
     的特殊方式。这意味这旋转矩阵中的每个元素等于一个输入基矢量与另一个输出基矢量的点积。

     假设第一个坐标空间的基矢量是相互正交的单位矢量p,q,r，具有相同原点的第二个坐标空间的
     基矢量是p',q',r'（这里写出 hat 符号，是为了防止混乱）。
     将矢量从第一个空间旋转到第二个空间的旋转矩阵可用每对基矢量之间的角度的余弦构造。
     而两个单位矢量的点积正好等于它们之间角度的余弦。*)

  (* 注意，有两种形式：它们所使用的旋转矩阵是互为转置的。分别介绍：
     第一种形式，书中的，在旋转矩阵的左侧使用行矢量。
     LR (Left-Row): row-vector left multiply matrix

     第二种形式，我习惯的，在旋转矩阵的右侧使用列矢量
     RC (Right-Column): matrix right multiply column-vector.
   *)

  (* 两个坐标空间的基向量（用行矢量、列矢量都无所谓了） *)
  Variable p q r p' q' r' : vec 3.

  (** ========================================= *)
  (** LR 形式 *)
  
  (* 构造出的旋转矩阵，作用：将某限量在第一个空间下的坐标变换到第二个空间下的表示 *)
  Definition LRmat : smat 3 :=
    l2m [[<p,p'>; <q,p'>; <r,p'>];
         [<p,q'>; <q,q'>; <r,q'>];
         [<p,r'>; <q,r'>; <r,r'>]].

  (* 用法 *)
  Definition LRrot (v : rvec 3) : rvec 3 := v * LRmat.

  (** 假设这些轴是相对于第一个基来描述的，则p,q,r是平凡的形式 [1,0,0],...，而第二个
        空间的基矢量p',q',r'是任意的坐标。我们可以发现：
        矩阵的行是输出坐标空间的基矢量（用相对于输入坐标空间的坐标来表示） *)
  Lemma LR_row_is_output_basis :
    p = v3i -> q = v3j -> r = v3k ->
    (mrow LRmat #0 = p' /\ mrow LRmat #1 = q' /\ mrow LRmat #2 = r').
  Proof.
    intros. unfold LRmat. subst. v2e p'; v2e q'; v2e r'.
    repeat split; veq; ring.
  Qed.

  (** 假设这些轴是相对于第二个基来描述的，则p',q',r'是平凡的形式 [1,0,0],...，而第一个
        空间的基矢量p,q,r是任意的坐标。我们可以发现：
        矩阵的列是输入坐标空间的基矢量（用相对于输出坐标空间的坐标来表示） *)
  Lemma LR_col_is_input_basis :
    p' = v3i -> q' = v3j -> r' = v3k ->
    (mcol LRmat #0 = p /\ mcol LRmat #1 = q /\ mcol LRmat #2 = r).
  Proof.
    intros. unfold LRmat. subst. v2e p; v2e q; v2e r.
    repeat split; veq; ring.
  Qed.
  
  (** ========================================= *)
  (** RC 形式 *)
  
  (* 构造出的旋转矩阵，作用：将某限量在第一个空间下的坐标变换到第二个空间下的表示 *)
  Definition RCmat : smat 3 :=
        l2m [[<p,p'>; <p,q'>; <p,r'>];
             [<q,p'>; <q,q'>; <q,r'>];
             [<r,p'>; <r,q'>; <r,r'>]].

  (* 用法 *)
  Definition RCrot (v : vec 3) : vec 3 := RCmat *v v.

  (** RCmat 是 LRmat 的转置 *)
  Lemma RCmat_LRmat_trans : RCmat = LRmat \T.
  Proof. meq. Qed.

  (** 假设这些轴是相对于第一个基来描述的，则p,q,r是平凡的形式 [1,0,0],...，而第二个
        空间的基矢量p',q',r'是任意的坐标。我们可以发现：
        矩阵的列是输出坐标空间的基矢量（用相对于输入坐标空间的坐标来表示） *)
  Lemma RC_col_is_output_basis :
    p = v3i -> q = v3j -> r = v3k ->
    (mcol RCmat #0 = p' /\ mcol RCmat #1 = q' /\ mcol RCmat #2 = r').
  Proof.
    intros. unfold RCmat. subst. v2e p'; v2e q'; v2e r'.
    repeat split; veq; ring.
  Qed.

  (** 假设这些轴是相对于第二个基来描述的，则p',q',r'是平凡的形式 [1,0,0],...，而第一个
        空间的基矢量p,q,r是任意的坐标。我们可以发现：
        矩阵的行是输入坐标空间的基矢量（用相对于输出坐标空间的坐标来表示） *)
  Lemma RC_row_is_input_basis :
    p' = v3i -> q' = v3j -> r' = v3k ->
    (mrow RCmat #0 = p /\ mrow RCmat #1 = q /\ mrow RCmat #2 = r).
  Proof.
    intros. unfold RCmat. subst. v2e p; v2e q; v2e r.
    repeat split; veq; ring.
  Qed.

End sec_8_2_2.


(** ** 8.2.3 矩阵形式的优点 *)

(* 这是一种非常明确的表示方向的形式。有以下优点：
   1. 旋转矢量立即可用。可以使用矩阵在对象空间和直立空间之间旋转矢量。其他方式几乎都
   需要先转换到旋转矩阵来处理。（尽管四元数说可以，但还是在乘以另一种形式的旋转矩阵。）
   2. 这是图形API使用的格式。
   3. 多个角位移的连接。在第3章讨论了坐标空间的嵌套，第5.6介绍了矩阵的连接方法。
   4. 使用矩阵求逆来计算“反向”的角位移。而且由于旋转矩阵是正交的，只需要转置一下即可。*)

(** ** 8.2.4 矩阵形式的缺点
   1. 矩阵占用更多内存。9个数字来存储朝向，而不是3个数字。
   2. 人类难以使用。矩阵对于人类直接使用并不直观，数字都介于-1~+1，而且人们习惯角度。
   另外，手动构建一个非平凡的朝向需要很长时间。
   3. 矩阵可能格式不正确。矩阵中的9个数字，但实际只需3个。换言之，矩阵包含6度冗余。
   必须满足6个约束条件才能使矩阵有效表示朝向。行(列)正交且单位向量。
   
   格式错误的矩阵可能导致数字异常、奇怪的拉伸图形和其他意外行为。
   有如下可能的图形得到一个病态的矩阵：
   1. 可能包含缩放比例、倾斜、反射、投影，而经过此类运算后的对象的朝向是未定义的。
   2. 可能从外部获取了错误的数据。许多建模软件包可能生成不良格式。
   3. 由于浮点数摄入错误。大量的矩阵乘法受到有限的浮点精度的影响，可能导致格式错误的
   矩阵。这种现象称为矩阵蠕变（matrix creep）。可通过6.3.3的矩阵正交化来应对。 *)

(** * 8.3 欧拉角 *)

(** ** 8.3.1 欧拉角约定 *)

(* 欧拉角的基本思想：将角位移定义为绕3个轴的3个旋转的序列。很直观。
   但是，究竟是哪些轴？什么旋转顺序？事实上，任何顺序的任何3个轴都可以工作。
   最常见的约定，也是本书的约定，欧拉角是“航向-俯仰-滚转”约定。
   航向角（Heading Angle）、俯仰角（Pitch Angle）、滚转角（Bank Angle）。

   本文的左手系统约定：+y向右，+y向上，+z向前。
   而右手系中一般的约定：+x向前，+y向右，+z向下。

   以本文的左手系为例，具体步骤：
   1. 从相等定向开始（对象空间轴与直立轴对齐）
   2. 航向绕y旋转。
   3. 在应用航向旋转后，俯仰绕x（对象空间的）旋转。
   4. 在应用了航向角和俯仰角后，滚转绕z轴（对象空间的）旋转。
   注意：所有的正向都按照左手系来定义。*)

(** ** 8.3.2 其他欧拉角约定 *)

(** 备注：本本节左手系中，对象的横轴是飞机左机翼指向右机翼的方向；纵轴是机头指向机尾的
    方向；垂直轴是机体垂直指向顶部的方向。*)

(* 有很多变体来定义旋转。本节讨论一些非常重要的概念，希望消除混乱的根源。

   首先是一个命名问题。在航空航天领域，使用偏航角(Yaw)-俯仰角(Pitch)-翻滚角(Roll)。
   （到底哪个是本尊，哪个是变体，都不一定）
   这里，术语Roll与Bank完全同义(中文有：翻滚、滚转、横滚等）。
   术语偏航(Yaw)和航向(Heading)相同，只是偏航(Yaw)有一点微妙的不同含义。
   因此，基本上Yaw-Pitch-Roll与Heading-Pitch-Bank是相同的系统。

   还有一些不太常见的术语也在使用。
   航向也被称为方向角(Azimuth)；
   称为“俯仰”的垂直角度也被称为飞机的姿态(Attitude)角或爬升角(Elevation)。
   滚转角，也被称为倾斜(Tilt)角或扭转(Twist)角。
   
   刚问了ChatGPT:
   # 请问飞机的姿态角(Attitude)是什么？是如何定义的？
   @ 飞机的姿态角指的是飞机相对于水平面的三个旋转角度，也可以被称为姿态或者航向姿态。
     常见的姿态角包括俯仰角（Pitch）、偏航角（Yaw）和滚转角（Roll）。具体来说，
     俯仰角是飞机机身纵轴与地面平面夹角的大小，
     偏航角是飞机机身竖直轴与地面平面夹角的大小，
     滚转角则是飞机机身横轴与地面平面夹角的大小。
     这些角度可以被用来描述飞机相对于水平面的方向和倾斜程度。在飞机的控制中，姿态角是非常
     重要的概念，因为它们可以被用来控制飞机的方向和稳定性。飞机的自动控制系统可以根据测量
     到的姿态角来调整飞机的飞行状态，使其保持平稳的飞行。

   还有一些数学家会使用希腊字母来表示这三个角度：
   (ϕ,θ,ψ)  (ψ,θ,ϕ)   (Ω,i,ω)   (α,β,γ)

   这些当然只是表面上的差异。更有趣的是，我们会经常看到相反顺序列出的三个单词：
   roll-pitch-yaw。
   考虑到旋转顺序非常重要，这里难道真的只是以相反顺序列出它们吗？
   事实上，这种“相反”的约定有一个合理的解释，它是我们实际在计算机内执行旋转的顺序。
   （从坐标轴按此顺序变换到直立轴）

   固定轴(Fixed-Axis)与欧拉角系统密切相关。
   在欧拉角系统中，旋转围绕体轴发生，体轴在每次旋转后发生变化。
   相反，在固定轴系统中，旋转轴始终是固定的直立轴（Upright Axis）。
   事实证明，固定轴系统和欧拉角系统实际上等效，只要以相反的顺序进行旋转。
   
   【这一点，最好能够形式化的验证一下】

   固定轴约定也称为外旋(Extrinsic Rotation)，
   典型的欧拉角约定被称为内旋(Intrinsic Rotation)。

   许多航空术语继承自航海术语。Aeronautics可拆分为aero和nautical，其中，Aero的词根是
   Air, 而 nautical 的词根是 naut，有“航海的”意思。
   因此，aeronautics的字面意思是“空气和海洋”，是指空中和水上的交通运输和相关技术。

   关于偏航(Yaw)这个术语，其原始含义与航向(Heading)基本相同，但是：
   1. 在飞机的上下文中并不同。偏航是围绕对象空间y轴的旋转，而航向是绕直立空间y轴的旋转。
   当飞机是俯冲姿势时，如果飞行员执行90度偏航，则是耳朵着地，等于是滚转了90度。
   2. 在第一人称射击游戏中，玩家从左向右移动鼠标控制角色时，他正在执行航向旋转，
   因为始终绕垂直轴(直立空间的y轴)。而当玩家向下看并且水平移动鼠标执行航向旋转，则他们
   的角色将继续向下卡并旋转到位。
   
   这两个例子并不是要说航向角比偏航角好。关键是通过调整单个欧拉角并不能实现偏航移动，
   而航向角可以。相同的讨论还可应用于俯仰。
   但是，没有一个真正足够简单而又很好的词来描述队形的纵轴与水平面形成的角度。
   
   本书没有遵循航空航天领域的右手坐标约定。
   理论上虽然任何3个轴可用任何顺序旋转，但实际上仍希望选择具有意义的约定。
   无论怎样标记轴，第1个角度是绕竖直轴旋转；第2个角度是绕机体横轴；第3个是机体纵轴。

   再多讨论一些。刚才的描述中每次旋转都发生在不同的体轴上。然而，欧拉的原始系统是一个
   “对称”系统，其中的第1次和第3次是绕同一个轴。这些方法在某些情况下更方便。
   为了区分这两个系统，对称的欧拉角也称为真典欧拉角（Proper Euler Angle），
   更常见的三个不同轴的约定称为Tait-Bryan Angles。 *)

(** ** 8.3.3 欧拉角的优点 *)

(* 1. 易于人类使用。三个数字都是角度，是人们思考定向的自然方式。
   2. 使用尽可能最小的表示。只有3个数字，如果优先考虑内存，则欧拉角是表示朝向最经济的。
      由于欧拉角是角度，因浮点数量化引起的数据丢失会均匀分布。而旋转矩阵和欧拉角要求使用
      非常小的数字，它们存储的值是角度的正弦和余弦。但这两个值的绝对值差异即使很小，其
      引起的差异也很大。
   3. 任何一组3个数字都有效。换言之，没有一组无效的欧拉角。而矩阵和四元素则不是这样的。*)

(** ** 8.3.4 欧拉角的缺点 *)

(** 1. 给定定向的表示不唯一。
    2. 两个定向之间的插值是有问题的。*)

(* 首先，别名现象。第一种是普通别名，添加 2π 倍数。第二种是更麻烦的，三个角度彼此不完全
   独立。例如俯仰135，等于{先偏航180，再俯仰45，再滚转180}
   
   在处理球面坐标别名时，当时建立了规范集（Canonical Set）发现很有用。
   对欧拉角也是用这种技术，限制角度的范围。常见的：航向和滚转为(-π,π]，俯仰为[-π/2,π/2]。
   
   欧拉角最著名的别名现象称为万向节死锁（Gimbal Lock），即第二次旋转±π/2时会会引起第1次
   和第3次是旋转了同一个轴，丢失了一个自由度。
   一种简单的做法时，当俯仰角为±π/2时，滚转角置为0。

   规范集中欧拉角满足的条件：
    - π < h <= π        Heading (yaw)
    - π/2 <= p <= π/2   Pitch
    - π < b <= π        Bank (roll)
    p = ± π/2  ==>  b = 0

    一个常见的误解，由于万向节锁，使用欧拉角无法描述某些定向。实际上，要描述定向，别名
    不会有问题。因为，欧拉角可描述三维中的任何方向，且在规范集中是唯一的。*)

(* 其次，插值会有什么问题？
   插值是指在两个朝向 R0 和 R1 之间插值，对于参数t∈[0,1]，希望算出中间值R(t)，使得t变化
   时，朝向从R0到R1平滑地插值。
   一种简单的方式，把标准线性插值（lerp：Linear interpolation）独立应用于3个角度：
   Δθ = θ1 - θ0,  θt = θ0 + t * Δθ
   但这里有一些问题：
   1. 不规范的欧拉角可能产生很大的角度值。解决方法是：要规范化。
   2. 即使都在规范内，由于角度的循环特性，可能会错误的工作。
   例如 -170 和 170 的两个朝向，会错误的旋转340度，而不是较短的20度。
   解决方法是，将插值方程中的角度差限制在 (-π,π]。
   3. 万向节死锁的影响。往往导致不稳定，不自然的情况。
   因为朝向的参数空间具有不连续性，朝向的微小变化可能导致各个角度的很大变化。
   这是一个根本性的问题。任何使用3个数字来描述三维朝向的一个固有的问题。
   指数映射形式是是另一种不同方案，它能改善，但不能完全消除。为此，必须使用四元数。*)

(** * 8.4 轴-角和指数映射表示方式 *)

(** 根据欧拉旋转定理（Euler's Rotation Theorem），意味着，任何三维角位移都可以通过绕
    一个轴进行一次旋转来完成。确切的，任意两个朝向R1,R2，存在一个轴 n̂，使得绕 n̂ 旋转
    一次可以从 R1 到达 R2。
    使用欧欧拉角需要3次旋转，因为被限制为绕基本轴旋转。
    本节将证明，这个旋转轴是唯一的。*)

(* 以两个值 n̂ 和 θ 为例，可以描述 Axis-Angle 形式的角位移。
   用 θ 乘以 n̂ 得到单个矢量 e = θ n̂，则是指数映射（Exponential Map）。
   由 θ = |e|，n̂ = 归一化e，可以得到指数映射对应的轴和角。
   指数映射比轴角更紧凑（使用3个数字而不是四个），它避免了某些奇点并具有更好的
   插值和微分特性。

   这两种方式在实践中有点专业化。轴角格式是一种概念性的工具，其直接使用较少。
   一个值得注意的能力是，可直接获得位移的任意倍数。就是旋转轴不变，只改变θ。
   另外，四元数也可通过幂运算来实现。但检查其数学，它实际上是在底层使用轴-角格式。
   （尽管四元数声称其底层使用的是指数映射）。
   四元数也可使用球形插值 Slerp，但是不能存储 π 以上的旋转的能力。

   指数映射比轴角更常用。它的插值特性比欧拉角好。（它确实有奇点，但不像欧拉角那么麻烦）
   当人们想到内插旋转时，立即想到四元数。

   任何可以通过旋转矩阵描述的角位移，指数映射是唯一的。
   当限制了指数映射的子集（|e| <= 2π 的指数映射），则与旋转矩阵形成一对一的对应关系。
   
   一些替代的术语：旋转矢量。
   相关术语：李代数、李群。*)


(** ** 8.5 四元数 *)
?
Open Scope quat_scope.

(* 本节会偏离传统的表述方式（将四元数解释为复数），相反，从几何角度介绍四元数。
   本节给出四元数的细节，以表明四元数的所有内容都可以推导出来。*)

(** ** 8.5.1 四元数表示法 (Notation)  *)
Section sec_8_5_1.

  Let q1 : quat := quat_of_s_v 4 (l2cv [1;2;3]).
  Let q2 : quat := quat_of_ssss 1 2 3 4.
  
  Compute q2cv q1.
  Compute cv2q (q2cv q1).
End sec_8_5_1.

(** ** 8.5.2 这4个数字的意思 *)
Section sec_8_5_2.
  (* 四元数形式与 8.4 的轴-角、指数映射形式密切相关。
     轴-角表示法：单位矢量 n̂ 定义旋转轴，标量 θ 是绕该轴的旋转量，(θ,n̂)定义了角位移。*)

  (** 四元数的几何意义，以及如何与轴角关联：*)
  Print quat_of_aa.
End sec_8_5_2.

(** ** 8.5.3 四元数取负 *)
Section sec_8_5_3.
  Check qopp.

  (* 注意，q 和 -q 描述相同的角位移。三维中的任何角位移在四元数格式中有两个表示，互为负数。
     可以这样试验：将 2π 加到 θ，并没有改变三维中的角位移，而q会成为 -q。*)
End sec_8_5_3.

(** ** 8.5.4 四元数单位元 *)
Section sec_8_5_4.
  Print qone.
End sec_8_5_4.

(** ** 8.5.5 四元数的大小 *)
Section sec_8_5_5.
  Print qlen.

  (** 旋转四元数有单位的大小 *)
  Check qrotation_imply_qunit.
End sec_8_5_5.

(** ** 8.5.6 四元数的共轭和逆 *)
Section sec_8_5_6.
  Check qconj.
  Check qinv.

  (* 如果只关注表示旋转的四元数，因它们都是单位四元数，所以其共轭和逆等价 *)
  Check qrotation_imply_qinv_eq_qconj.

  (* 共轭表示相反的角位移。以为共轭的旋转轴是相反的，它颠倒了正方向。
     所以，若 q 表示绕某个轴旋转 θ，则 q* 表示绕该轴旋转 -θ *)

End sec_8_5_6.

(** ** 8.5.7 四元数乘法 *)
Section sec_8_5_7.
  (* 分量形式的乘法公式 *)
  Check qmul.
  (* 矢量形式的乘法公式 *)
  Check qmulVEC.

  Check qmul_assoc. (* 结合律 *)
  Check qmul_comm_fail. (* 交换律不成立 *)
  Check qlen_qmul. (* 乘积的大小等于各自大小的乘积 *)
  Check qinv_qmul. (* 乘积的逆等于各自逆以相反的顺序相乘 *)

  (* 四元数乘法来旋转三维矢量 
     p' = q * p * q⁻¹
     一些讨论：上述紧凑的表示法有各种有点，但它在实际计算中是否有真正的好处？
     如果进行这个计算，可能发现这个工作量大致等同于“将四元数转换为旋转矩阵，然后做
     矩阵和矢量的乘法”。使用公式 8.20 做四元数到旋转矩阵的转换。*)

  (* 将多个旋转应用于矢量
     p' = b (a p a⁻¹) b⁻¹ = (ba) p (ba)⁻¹
     相当于通过 ba 执行单次旋转 *)

End sec_8_5_7.

(** ** 8.5.8 四元数的“差” *)
Section sec_8_5_8.
  (* 不太常用，在 Slerp 时用到 *)
End sec_8_5_8.

(** ** 8.5.9 四元数点积 *)
Section sec_8_5_9.
  (* 不太常用，在 Slerp 时用到 *)
End sec_8_5_9.

(** ** 8.5.10 四元数的对数、指数(Expential function) 和标量乘法 *)
Section sec_8_5_10.
  
End sec_8_5_10.

(** ** 8.5.11 四元数指数（取幂 Exponentiation）*)
Check qpower.

(** ** 8.5.12 四元数插值 *)
Check qslerp.

(** ** 8.5.13 四元数的优缺点 *)

(*
  优点：
  1. 平滑插值。Slerp插值方法提供了朝向之间的平滑插值。
  2. 角位移的快速连接和逆。可使用四元数乘积将一系列角位移连接称单个角位移，而使用矩阵的
  相同运算涉及更多的标量运算。当然，在给定体系结构中，哪一个更快并不确定。因为单指令多
  数据（SIMD）矢量运算可以快速的执行矩阵乘法。
  另外，四元数共轭提供了有效计算相反角位移的方法。相比而言，使用转置旋转矩阵来完成，
  但这对于欧拉角来说还需要额外的计算。
  3. 矩阵形式的快速转换。（在8.7节）四元数也可快速的与矩阵形式相互转换，转换速度比
  欧拉角更快一些。
  4. 只有4个数字，比矩阵更经济（但比欧拉角还是要多）。
  
  缺点：
  1. 存储成本略大于欧拉角。
  2. 相比欧拉角或指数映射，更难以打包成定点数（Fixed-Point Number）。因为四元数的值并不是
  在[-1,+1]之间“均匀间隔”的，即使方向是均匀间隔的，分量也不会平滑插值。
  3. 可能无效。因错误的输入后累积的浮点摄入误差而发生。可规范化四元数来确保它具有单位
  大小来解决。
  4. 人类难以使用。相比矩阵、欧拉角，四元素更难以使用。 *)

(** ** 8.5.14 作为复数的四元数 *)

Section sec_8_5_14.
  (* 本节将对四元数的发明及数学遗产做一些讨论 *)

  (* 首先，在 2*2 矩阵嵌入实数集。采用这种做法：在主对角线上放入该实数。
     这种形式矩阵是 2*2矩阵的子集，它与实数集可建立一一对应。
     该方法会保留加法、减法和乘法，甚至除法（将乘以矩阵逆当做除法），以及所有普通代数
     定律：结合律、分配律、零的不可约性质 *)
  Definition real2mat (r : R) : smat 2 := l2m [[r; 0]; [0; r]].

  (* 接着，为复数集合创建类似的映射。
     可验证，复数标准表示法 a +i b 和矩阵形式表示法的代数运算和基本定律都成立。
     另外，注意到复数的共轭与矩阵的转置恰好对应。*)
  Definition complex2mat (c : C) : smat 2 := l2m [[c.a; c.b]; [-c.b; c.a]]%R.
  (* 注意，这里有两种形式，上面是用于列向量右乘，而Dunn的书使用转置，用于行向量左乘。*)

  (* 甚至可以自动类型转换 *)
  (* Coercion real2mat : R >-> Matrix.mat. *)
  (* Coercion complex2mat : C >-> Matrix.mat. *)

  (* Open Scope mat_scope. *)
  (* Definition m1 := real2mat 1. *)
  (* Variable r : R. *)
  (* Variable c : C. *)
  (* Compute m2l(r + m1). *)
  (* Compute m2l(c + m1). *)

  (* 这样做的话，不需要虚构的 i（-1的平方根），而是将复数 a +i b 视为具有两个自由度的
     数学实体。通常称实部a是主要的自由度，虚部b是次要的自由度。两者在某种意义上正交。*)
  (* 继续深入，该方案可表示任意角度θ的旋转。
     复数 cosθ +i sinθ 的矩阵形式恰好就是 5.1.1 推导出的 2x2 旋转矩阵。
     由于旋转矩阵都是正交矩阵，所以它们的逆等于转置。*)

  (* 提示：在2D中，可以将矢量 [x,y] 解释为 x +i y，并使用复数乘法
     (cosθ +i sinθ) (x +i y) 来旋转它。*)

  (* 乘以复数 i，可解释为90度旋转。根据 i^2 = -1，可解释为旋转两个90度，得到旋转180度）。
     推广它，则任何具有单位长度的复数都可以写为 cosθ +i sinθ 并被解释为按角度 θ 旋转。
     所以，二维矢量转换为复数形式并乘以 cosθ +i sinθ 将被旋转。

     将该技巧从2D扩展到3D？直接的方式不可行，Hamilton曾经的工作（尝试用1个实部和2个虚部
     来表示的一种复数）。我们无法得知为什么Hamilton认识到复数的三维系统不好，但可以证明，
     这样的一个集合不能轻易地映射到 3x3 矩阵和旋转。
     
     四元数通过3个虚部i,j,k来扩展复数系统，并满足如下的 哈密尔顿规则：
     i^2 = j^2 = k^2 = -1
     ij = k, ji = -k
     jk = i, kj = -i
     ki = j, ik = -j
     四元数 [w,(x,y,z)]对应于复数w+ix+jy+kz，按照 8.5.7 给出的四元数乘积遵循这些规则。

     那么，是否可以将四元数集嵌入到矩阵集中，并满足上面的哈密尔顿规则？是的。

     这里存在 48 种不同的这种形式的矩阵表示，其中一个矩阵表示标量部分，其他三个都是斜对称的。
     更准确地说，有 48 组具有这些对称约束的四元组矩阵，使得将 1、i、j 和 k 发送到四元组中
     的矩阵的函数是同态的，也就是说，它将四元数的和和乘积发送到 sums和矩阵的产品。

     实数a      i               j             k
     [a 0 0 0]  [ 0  0  0  1]  [ 0  0  1  0]  [ 0 -1  0  0]
     [0 a 0 0]  [ 0  0 -1  0]  [ 0  0  0  1]  [ 1  0  0  0]
     [0 0 a 0]  [ 0  1  0  0]  [-1  0  0  0]  [ 0  0  0  1]
     [0 0 0 a]  [-1  0  0  0]  [ 0 -1  0  0]  [ 0  0 -1  0]
     
     可证明，这些映射确实保留了哈密尔顿的所有规则。*)
  (* matrix for a *)
  Let m4a (a : R) : smat 4 := l2m [[a;0;0;0]; [0;a;0;0]; [0;0;a;0]; [0;0;0;a]].
  Let m4i : smat 4 := l2m [[0;-1;0;0]; [1;0;0;0]; [0;0;0;-1]; [0;0;1;0]].
  Let m4j : smat 4 := l2m [[0;0;-1;0]; [0;0;0;1]; [1;0;0;0]; [0;-1;0;0]].
  Let m4k : smat 4 := l2m [[0;0;0;-1]; [0;0;-1;0]; [0;1;0;0]; [1;0;0;0]].

  Goal (m4i * m4i = -(m4a 1))%M. lma. Qed.
  Goal (m4j * m4j = -(m4a 1))%M. lma. Qed.
  Goal (m4k * m4k = -(m4a 1))%M. lma. Qed.

  Goal (m4i * m4j = m4k)%M. lma. Qed.
  Goal (m4j * m4i = - m4k)%M. lma. Qed.
  
  Goal (m4j * m4k = m4i)%M. lma. Qed.
  Goal (m4k * m4j = - m4i)%M. lma. Qed.
  
  Goal (m4k * m4i = m4j)%M. lma. Qed.
  Goal (m4i * m4k = - m4j)%M. lma. Qed.

  (* 此时，任意四元数可以映射到 4x4 矩阵 *)
  Let m4q (q : quat) : smat 4 := (m4a (q.W) + q.X c* m4i + q.Y c* m4j + q.Z c* m4k)%M.

  (* 展开后的形式 *)
  Let m4q' (q : quat) : smat 4 :=
        let '(w,x,y,z) := (q.W, q.X, q.Y, q.Z) in
        l2m [[w; -x; -y; -z];
             [x; w; -z; y];
             [y; z; w; -x];
             [z; -y; x; w]]%R.
  
  (* 可以验证两个表示相等 *)
  Goal forall q : quat, m4q q = m4q' q. lma. Qed.

  (* 目前为止，任意的四元数都使用。我们现在关注旋转。（这里的推导只是一家之言），
     而网上 Krasjet 的那篇又是另一种思路。*)

End sec_8_5_14.

(** ** 8.5.15 四元数概要 *)

(* 已经讨论了很多数学，其中大部分都不重要。下面是一些需要记住的事实
   1. 四元数可以使用旋转轴和旋转角度来来表示角位移。
   2. 四元数的标量分量w和矢量分量v，与旋转角θ和旋转轴n̂的关系：
      w = cos(θ/2),  v = n̂ sin(θ/2)
   3. 三维中的每个角位移在四元数空间都有两个不同表示，互为相反数。
   4. 表示“无角度位移”的四元数单位元是 [1,(0,0,0)]
   5. 所有表示角位移的四元数都是“单位四元数”，其大小为1
   6. 四元数的共轭表示相反的角位移。四元数的逆是共轭除以大小。
   7. 四元数乘法可将多个旋转连接成单个角位移。
      理论上，四元数乘法也可用于执行三维矢量旋转，但可能并不实用。
   8. 四元数取幂可用于计算角位移的倍数。但是四元数总是采用最短的弧，可能无法表示多圈。
   9. 四元数可以被解释为四维复数，可以在代数和几何之间建立联系。*)


(** * 8.6 方法比较 *)

(* 矩阵、欧拉角、指数映射、四元数的比较 *)

(** * 8.7 表示方式之间的转换 *)

